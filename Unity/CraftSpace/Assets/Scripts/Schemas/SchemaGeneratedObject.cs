//------------------------------------------------------------------------------
// <file_path>Unity/CraftSpace/Assets/Scripts/Schemas/SchemaGeneratedObject.cs</file_path>
// <namespace>CraftSpace</namespace>
// <assembly>Assembly-CSharp</assembly>
//
// IMPORTANT: This is the BASE CLASS for all schema-generated objects.
// It is NOT auto-generated and should be carefully maintained.
// It handles JSON serialization/deserialization and extra fields.
//
// THIS IS THE SHARED FOUNDATION FOR ALL SCHEMA CLASSES.
// Put common functionality here rather than duplicating in Item.cs or Collection.cs.
// When making changes, verify against the schema generator to ensure compatibility.
//
// ALWAYS:
// 1. Update the schema generator when adding/changing base functionality
// 2. Regenerate schema classes when base class changes
// 3. Keep the API consistent with what the generator expects
// 4. Fix errors in the schema generator FIRST before modifying this class
//
// CRITICAL WORKFLOW FOR SCHEMA CHANGES:
// - DO NOT MODIFY the generated schema classes (*.Schema.cs files)
// - If generated files have errors, fix SchemaGenerator.cs FIRST
// - IF you need to add custom functionality, add it to extension classes (Item.cs, Collection.cs)
// - KEEP those extension classes as thin as possible
// - PUT shared functionality here in SchemaGeneratedObject.cs
//
// EXTRAFIELDS IMPLEMENTATION:
// - The 'extraFields' property is ONLY defined in this C# base class
// - It is NOT part of the JSON schema or Zod schema definitions
// - Its purpose is to capture and preserve any properties from JSON that aren't
//   defined in the schema
// - This allows for backward compatibility with changing data sources
// - It should be treated as an internal implementation detail
//------------------------------------------------------------------------------

using UnityEngine;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;

/// <summary>
/// Base class for all schema-generated objects.
/// Handles JSON serialization/deserialization and extra fields.
/// This class provides the runtime framework for reflection-free JSON handling,
/// working in conjunction with the explicit code generated by SchemaGenerator.cs.
/// It avoids reliance on reflection-based features of JSON.NET that are incompatible
/// with IL2CPP/WebGL builds.
/// </summary>
public abstract class SchemaGeneratedObject : ScriptableObject
{
    [SerializeField] protected JObject extraFields = new JObject();
    
    /// <summary>
    /// Abstract property for the unique identifier. Must be implemented by generated classes.
    /// </summary>
    public abstract string Id { get; set; }
    
    /// <summary>
    /// Import data from JSON string. Parses the JSON and then calls the generated
    /// ImportKnownProperties and the base ImportExtraFields for deserialization,
    /// avoiding reflection for user-defined types.
    /// </summary>
    public virtual void ImportFromJson(string json)
    {
        try
        {
            Debug.Log($"[SchemaGeneratedObject] Beginning ImportFromJson in {GetType().Name}");
            Debug.Log($"[SchemaGeneratedObject] Parsing JSON string of length {json?.Length ?? 0}");
            
            // Log a preview of the JSON string (first 100 chars)
            string jsonPreview = json?.Length > 100 ? json.Substring(0, 100) + "..." : json;
            Debug.Log($"[SchemaGeneratedObject] JSON preview: {jsonPreview}");

            if (string.IsNullOrEmpty(json))
            {
                Debug.LogWarning($"[SchemaGeneratedObject] Empty JSON string passed to {GetType().Name}.ImportFromJson");
                return;
            }

            JObject data = null;
            try 
            {
                data = JObject.Parse(json);
                Debug.Log("[SchemaGeneratedObject] JSON successfully parsed");
            }
            catch (Exception parseEx)
            {
                Debug.LogError($"[SchemaGeneratedObject] Failed to parse JSON: {parseEx.Message}");
                Debug.LogError($"[SchemaGeneratedObject] Parse error stack trace: {parseEx.StackTrace}");
                return; // Exit early if we can't parse the JSON
            }
            
            // Clear existing extra fields before import
            extraFields = new JObject();

            // --- Call abstract/virtual methods --- 
            try
            {
                Debug.Log($"[{GetType().Name}] Calling ImportKnownProperties");
                ImportKnownProperties(data); // Populate derived class fields (including Id)
                Debug.Log($"[{GetType().Name}] ImportKnownProperties completed successfully");

                // <<< SET NAME AFTER Id IS POPULATED >>>
                SetUnityObjectName();

                Debug.Log($"[{GetType().Name}] Calling ImportExtraFields");
                ImportExtraFields(data); // Populate extra fields
                Debug.Log($"[{GetType().Name}] ImportExtraFields completed successfully");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[SchemaGeneratedObject] Error in ImportFromJson: {ex.Message}");
                Debug.LogError($"[SchemaGeneratedObject] Exception type: {ex.GetType().FullName}");
                Debug.LogError($"[SchemaGeneratedObject] Stack trace: {ex.StackTrace}");
                if (ex.InnerException != null)
                {
                    Debug.LogError($"[SchemaGeneratedObject] Inner exception: {ex.InnerException.Message}");
                }
            }
        }
        catch (Exception ex)
        {
            Debug.LogError($"[SchemaGeneratedObject] Error in {GetType().Name}.ImportFromJson: {ex.Message}");
            Debug.LogError($"[SchemaGeneratedObject] Exception type: {ex.GetType().FullName}");
            Debug.LogError($"[SchemaGeneratedObject] Stack trace: {ex.StackTrace}");
            if (ex.InnerException != null)
            {
                Debug.LogError($"[SchemaGeneratedObject] Inner exception: {ex.InnerException.Message}");
            }
        }
    }
    
    /// <summary>
    /// Import known properties from a JObject
    /// </summary>
    protected abstract void ImportKnownProperties(JObject json);
    
    /// <summary>
    /// Import extra fields from a JObject
    /// </summary>
    protected virtual void ImportExtraFields(JObject json)
    {
        Debug.Log($"[SchemaGeneratedObject] Starting ImportExtraFields in {GetType().Name}");
        try
        {
            if (json == null)
            {
                Debug.LogError($"[SchemaGeneratedObject] ImportExtraFields called with null JObject");
                return;
            }
            
            Debug.Log($"[SchemaGeneratedObject] Creating new JObject for extraFields");
            extraFields = new JObject();
            Debug.Log($"[SchemaGeneratedObject] extraFields initialized as empty JObject");
            
            int propertyCount = 0;
            foreach (var prop in json)
            {
                try
                {
                    var propertyName = prop.Key;
                    Debug.Log($"[SchemaGeneratedObject] Processing JSON property: {propertyName}");
                    
                    bool isDefined = HasDefinedProperty(propertyName);
                    Debug.Log($"[SchemaGeneratedObject] Property {propertyName} is defined in schema: {isDefined}");
                    
                    if (!isDefined)
                    {
                        Debug.Log($"[SchemaGeneratedObject] Adding extra field: {propertyName}");
                        extraFields[propertyName] = prop.Value;
                        propertyCount++;
                    }
                }
                catch (Exception propEx)
                {
                    Debug.LogError($"[SchemaGeneratedObject] Error processing property {prop.Key}: {propEx.Message}");
                    // Continue with the next property
                }
            }
            Debug.Log($"[SchemaGeneratedObject] Completed ImportExtraFields with {propertyCount} extra fields");
        }
        catch (Exception ex)
        {
            Debug.LogError($"[SchemaGeneratedObject] Error in ImportExtraFields: {ex.Message}");
            Debug.LogError($"[SchemaGeneratedObject] Error type: {ex.GetType().Name}");
            Debug.LogError($"[SchemaGeneratedObject] Stack trace: {ex.StackTrace}");
            if (ex.InnerException != null)
            {
                Debug.LogError($"[SchemaGeneratedObject] Inner exception: {ex.InnerException.Message}");
                Debug.LogError($"[SchemaGeneratedObject] Inner exception type: {ex.InnerException.GetType().Name}");
            }
            // Don't rethrow - we want to gracefully recover
        }
    }
    
    /// <summary>
    /// Export to JSON string
    /// </summary>
    public virtual string ExportToJson()
    {
        try
        {
            var json = new JObject();
            
            var knownProps = ExportKnownProperties();
            foreach (var prop in knownProps)
            {
                json[prop.Key] = prop.Value;
            }
            
            foreach (var prop in extraFields)
            {
                json[prop.Key] = prop.Value;
            }
            
            return json.ToString(Formatting.Indented);
        }
        catch (Exception ex)
        {
            Debug.LogError($"[SchemaGeneratedObject] Error in ExportToJson: {ex.Message}");
            throw;
        }
    }
    
    /// <summary>
    /// Export known properties to a JObject
    /// </summary>
    protected abstract JObject ExportKnownProperties();
    
    /// <summary>
    /// Check if a property is defined in the schema
    /// </summary>
    protected abstract bool HasDefinedProperty(string name);
    
    /// <summary>
    /// Convert to JSON string - canonical method
    /// </summary>
    public string ToJson()
    {
        return ExportToJson();
    }
    
    /// <summary>
    /// Convert to JSON string with optional pretty printing
    /// </summary>
    public string ToJsonString(bool prettyPrint = false)
    {
        try
        {
            if (prettyPrint)
            {
                return ExportToJson();
            }
            else
            {
                return JObject.Parse(ExportToJson()).ToString(Formatting.None);
            }
        }
        catch (Exception e)
        {
            Debug.LogError($"[{GetType().Name}] Error in ToJsonString: {e.Message}");
            return "{}";
        }
    }

    /// <summary>
    /// Sets the Unity ScriptableObject.name property based on the type and Id.
    /// Called automatically during ImportFromJson after known properties are populated.
    /// Format: "TypeName-IdValue"
    /// </summary>
    protected virtual void SetUnityObjectName()
    {
        try
        {
            string objectId = this.Id; // Now accesses the abstract property
            if (!string.IsNullOrEmpty(objectId))
            {
                this.name = $"{GetType().Name}-{objectId}";
            }
            else
            {
                 this.name = $"{GetType().Name}-MissingId_{GetInstanceID()}";
                 Debug.LogWarning($"[{GetType().Name}] Could not set object name using Id because Id property was null or empty. Using fallback: {this.name}");
            }
        }
        catch (Exception ex)
        {
             Debug.LogError($"[{GetType().Name}] Error setting ScriptableObject name: {ex.Message}");
             // Use a basic fallback name
             this.name = $"{GetType().Name}-NameError_{GetInstanceID()}";
        }
    }
} 