using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using CraftSpace;

namespace CraftSpace.Editor.SchemaGenerator
{
    /// <summary>
    /// Generates Unity ScriptableObject classes from JSON schemas
    /// </summary>
    public class ScriptableGenerator
    {
        private readonly SchemaType _schema;
        private readonly StringBuilder _code = new();
        private string _indent = "";

        public ScriptableGenerator(SchemaType schema)
        {
            _schema = schema;
        }

        public string GenerateCode()
        {
            // Add generated code header
            _code.AppendLine("//------------------------------------------------------------------------------");
            _code.AppendLine("// <auto-generated>");
            _code.AppendLine("//     This code was generated by CraftSpace Schema Generator.");
            _code.AppendLine("//     Runtime Version: 1.0");
            _code.AppendLine("//");
            _code.AppendLine("//     This is an auto-generated Unity ScriptableObject class for handling");
            _code.AppendLine("//     Internet Archive metadata. For more information, see:");
            _code.AppendLine("//     Assets/Editor/SchemaGenerator/README.md");
            _code.AppendLine("//");
            _code.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
            _code.AppendLine("//     the code is regenerated.");
            _code.AppendLine("// </auto-generated>");
            _code.AppendLine("//------------------------------------------------------------------------------");
            _code.AppendLine();

            // Add required using statements
            _code.AppendLine("using System;");
            _code.AppendLine("using System.Collections.Generic;");
            _code.AppendLine("using Newtonsoft.Json;");
            _code.AppendLine("using Newtonsoft.Json.Linq;");
            _code.AppendLine("using UnityEngine;");
            _code.AppendLine("using CraftSpace;");
            _code.AppendLine();
            
            // Add nullable enable
            _code.AppendLine("#nullable enable");
            _code.AppendLine();

            // Get Unity type attributes
            var typeAttrs = _schema.GetUnityTypeAttributes();
            var className = typeAttrs?.Title ?? "JsonScriptableObject";
            
            // Use the schema title as the class name
            string actualClassName = _schema.Title ?? className;
            
            // Generate the main ScriptableObject class
            GenerateScriptableObject(_schema, actualClassName);
            
            return _code.ToString();
        }

        private void GenerateScriptableObject(SchemaType schema, string className)
        {
            var typeAttrs = schema.GetUnityTypeAttributes();

            // Add class documentation
            if (!string.IsNullOrEmpty(typeAttrs?.Description))
            {
                _code.AppendLine($"{_indent}/// <summary>");
                _code.AppendLine($"{_indent}/// {typeAttrs.Description}");
                _code.AppendLine($"{_indent}/// </summary>");
            }

            // Add help URL if specified
            if (!string.IsNullOrEmpty(typeAttrs?.HelpUrl))
            {
                _code.AppendLine($"{_indent}[HelpURL(\"{typeAttrs.HelpUrl}\")]");
            }

            // Add custom icon if specified
            if (!string.IsNullOrEmpty(typeAttrs?.Icon))
            {
                _code.AppendLine($"{_indent}[Icon(\"{typeAttrs.Icon}\")]");
            }

            // Add menu path if specified
            var menuPath = typeAttrs?.ScriptableObjectCreateMenu?.MenuName ?? $"CraftSpace/{className}";
            var fileName = typeAttrs?.ScriptableObjectCreateMenu?.FileName ?? className;
            var order = typeAttrs?.ScriptableObjectCreateMenu?.Order ?? 0;

            // Create ScriptableObject class
            _code.AppendLine($"{_indent}[CreateAssetMenu(fileName = \"{fileName}\", menuName = \"{menuPath}\", order = {order})]");
            _code.AppendLine($"{_indent}public class {className} : SchemaGeneratedObject");
            _code.AppendLine($"{_indent}{{");

            // Generate nested type definitions if needed
            foreach (var prop in schema.Properties)
            {
                if (prop.Value.Type == "object")
                {
                    GenerateNestedClass(prop.Value, ConvertToPascalCase(prop.Key));
                }
            }

            // Generate properties
            GenerateProperties(schema.Properties);

            // We don't need to generate JSON methods as they're already in the base class
            
            _code.AppendLine($"{_indent}}}");
        }

        private void GenerateNestedClass(SchemaType schema, string className)
        {
            var typeAttrs = schema.GetUnityTypeAttributes();

            if (!string.IsNullOrEmpty(typeAttrs?.Description))
            {
                _code.AppendLine($"{_indent}/// <summary>");
                _code.AppendLine($"{_indent}/// {typeAttrs.Description}");
                _code.AppendLine($"{_indent}/// </summary>");
            }

            _code.AppendLine($"{_indent}[Serializable]");
            _code.AppendLine($"{_indent}public class {className}");
            _code.AppendLine($"{_indent}{{");

            foreach (var prop in schema.Properties)
            {
                if (prop.Value.Type == "object")
                {
                    GenerateNestedClass(prop.Value, ConvertToPascalCase(prop.Key));
                }
            }

            foreach (var prop in schema.Properties)
            {
                GenerateProperty(prop.Key, prop.Value, 3);
            }

            _code.AppendLine($"{_indent}}}");
            _code.AppendLine();
        }

        private void GenerateProperties(Dictionary<string, SchemaType> properties)
        {
            // Track all generated nested class names to avoid duplicates
            var nestedClassNames = new HashSet<string>();
            
            // First identify all nested classes
            foreach (var kvp in properties)
            {
                if (kvp.Value.Type == "object")
                {
                    nestedClassNames.Add(ToTitleCase(kvp.Key));
                }
            }
            
            foreach (var kvp in properties)
            {
                string name = kvp.Key;
                SchemaType prop = kvp.Value;
                
                // Skip if this property would conflict with a nested class name
                if (nestedClassNames.Contains(ToTitleCase(name)))
                {
                    Debug.Log($"Skipping property {name} to avoid conflict with nested class");
                    continue;
                }
                
                string propertyName = ToTitleCase(name);
                string backingFieldName = $"_{name}";
                string defaultValue = GetDefaultValueForType(prop.Type, null);
                string typeName = GetTypeNameForProperty(prop);
                
                // Check if this property is in the required array
                bool isRequired = _schema.Required != null && _schema.Required.Contains(name);
                bool isNullable = !isRequired && !IsValueType(typeName);
                
                GenerateProperty(name, prop, propertyName, backingFieldName, typeName, isNullable, defaultValue);
            }
        }

        private void GenerateProperty(string name, SchemaType prop, string propertyName, string backingFieldName, string typeName, bool isNullable, string defaultValue)
        {
            // Add description if available
            if (!string.IsNullOrEmpty(prop.Description))
            {
                _code.AppendLine($"{_indent}    /// <summary>");
                _code.AppendLine($"{_indent}    /// {prop.Description}");
                _code.AppendLine($"{_indent}    /// </summary>");
            }
            
            // Add JSON property attribute
            _code.AppendLine($"{_indent}    [JsonProperty(\"{name}\")]");
            
            // Add SerializeField for Unity inspector
            string nullableMarker = isNullable ? "?" : "";
            
            // Fix object/Object ambiguity by using System.Object for object types
            if (typeName == "Object" || typeName == "object")
            {
                typeName = "System.Object";
            }
            
            _code.AppendLine($"{_indent}    [SerializeField] private {typeName}{nullableMarker} {backingFieldName}{defaultValue};");
            
            // Add type converter if specified
            var typeConverter = GetTypeConverterForProperty(prop);
            if (typeConverter != null)
            {
                string options = "";
                if (typeConverter.Options != null)
                {
                    options = $", {JsonConvert.SerializeObject(typeConverter.Options)}";
                }
                _code.AppendLine($"{_indent}    [TypeConverter(\"{typeConverter.Name}\"{options})]");
                Debug.Log($"Applied TypeConverter {typeConverter.Name} to property {name}");
            }
            
            // Generate property
            _code.AppendLine($"{_indent}    public {typeName}{nullableMarker} {propertyName} {{ get => {backingFieldName}; set => {backingFieldName} = value; }}");
            _code.AppendLine();
        }

        private string ConvertToPascalCase(string name) =>
            string.Concat(name.Split('_', '-').Select(s => char.ToUpper(s[0]) + s.Substring(1)));

        private string ToTitleCase(string name) => ConvertToPascalCase(name);
        
        private TypeConverter GetTypeConverterForProperty(SchemaType prop)
        {
            var converter = prop.GetTypeConverter();
            if (converter == null) return null;
            
            // Return converter info
            return new TypeConverter { Name = converter.Name, Options = converter.Options };
        }
        
        private string GetTypeNameForProperty(SchemaType prop)
        {
            // Check for type converter first, which takes precedence
            var typeConverter = prop.GetTypeConverter();
            if (typeConverter != null && !string.IsNullOrEmpty(typeConverter.CSharpType))
            {
                return typeConverter.CSharpType;
            }
            
            // Otherwise use standard type mapping
            switch (prop.Type?.ToLower())
            {
                case "string":
                    return "string";
                case "number":
                    return "float";
                case "integer":
                    return "int";
                case "boolean":
                    return "bool";
                case "array":
                    var itemType = "object";
                    if (prop.Items != null)
                    {
                        itemType = GetTypeNameForProperty(prop.Items);
                    }
                    return $"List<{itemType}>";
                case "object":
                    return ConvertToPascalCase(prop.Title ?? "Object");
                default:
                    return "object";
            }
        }
        
        private string GetDefaultValueForType(string type, string format)
        {
            return ""; // No default values for now
        }
        
        private bool IsValueType(string typeName)
        {
            return typeName == "int" || 
                   typeName == "float" || 
                   typeName == "bool" || 
                   typeName == "double" || 
                   typeName == "decimal";
        }

        private void GenerateProperty(string name, SchemaType prop, int indentLevel)
        {
            // Skip if this property name matches a nested class name that would cause conflict
            if (name.Equals("extraFields", StringComparison.OrdinalIgnoreCase))
            {
                Debug.Log($"Skipping property {name} to avoid conflict with nested ExtraFields class");
                return;
            }
            
            string indent = new string(' ', indentLevel * 4);
            
            // Add description if available
            if (!string.IsNullOrEmpty(prop.Description))
            {
                _code.AppendLine($"{indent}/// <summary>");
                _code.AppendLine($"{indent}/// {prop.Description}");
                _code.AppendLine($"{indent}/// </summary>");
            }
            
            // Add JSON property attribute
            _code.AppendLine($"{indent}[JsonProperty(\"{name}\")]");
            
            string typeName = GetTypeNameForProperty(prop);
            
            // Fix object/Object ambiguity by using System.Object for object types
            if (typeName == "Object" || typeName == "object")
            {
                typeName = "System.Object";
            }
            
            // Check if this property is in the required array
            bool isRequired = _schema.Required != null && _schema.Required.Contains(name);
            bool isNullable = !isRequired && !IsValueType(typeName);
            
            // Add SerializeField for Unity inspector
            string nullableMarker = isNullable ? "?" : "";
            _code.AppendLine($"{indent}[SerializeField] private {typeName}{nullableMarker} _{name};");
            
            // Add type converter if specified
            var typeConverter = GetTypeConverterForProperty(prop);
            if (typeConverter != null)
            {
                string options = "";
                if (typeConverter.Options != null)
                {
                    options = $", {JsonConvert.SerializeObject(typeConverter.Options)}";
                }
                _code.AppendLine($"{indent}[TypeConverter(\"{typeConverter.Name}\"{options})]");
            }
            
            // Generate property
            _code.AppendLine($"{indent}public {typeName}{nullableMarker} {ToTitleCase(name)} {{ get => _{name}; set => _{name} = value; }}");
            _code.AppendLine();
        }

        /// <summary>
        /// Generates a C# class from a schema type
        /// </summary>
        public static string GenerateClass(SchemaType schema, string className)
        {
            var generator = new ScriptableGenerator(schema);
            return generator.GenerateCode();
        }
    }
} 